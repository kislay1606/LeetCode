//RECURSION
class Solution {
private:
    int solve(int index, vector<int>& heights, int k) {
        // base case
        if(index == 0) return 0;

        int minEnergy = INT_MAX;

        // try all jumps from 1 to k
        for(int i = 1; i <= k; i++) {
            if(index - i >= 0) { 
                int energy = solve(index - i, heights, k) 
                           + abs(heights[index] - heights[index - i]);
                minEnergy = min(minEnergy, energy);
            }
        }
        return minEnergy;
    }    
public:
    int frogJump(vector<int>& heights, int k) {
        int n = heights.size();
        return solve(n - 1, heights, k);
    }
};


//MEMOIZATION
class Solution {
private:
    int solve(int index,vector<int>& heights, int k,vector<int> &dp){
        int minEnergy=INT_MAX;

        //base case
        if(index==0) return 0;

        if(dp[index] != -1) return dp[index];

        for(int i=1; i<=k; i++){
            if(index-i >= 0){
                int energy=solve(index-i,heights,k,dp) + abs(heights[index]-heights[index-i]);
                minEnergy=min(minEnergy,energy);
            }
        }
        return dp[index]=minEnergy;
    }    
public:
    int frogJump(vector<int>& heights, int k) {
        int n=heights.size();
        vector<int>dp(n,-1);
        return solve(n-1,heights,k,dp);
    }
};


//TABULATION
class Solution {
private:
    int solve(vector<int>& heights, int k,vector<int> &dp){
        int n=heights.size();
        dp[0]=0;

        for(int i=1; i<n; i++){
            int minEnergy=INT_MAX;
            for(int j=1; j<=k; j++){
                if(i-j >= 0){
                    int energy=dp[i-j] + abs(heights[i]-heights[i-j]);
                    minEnergy=min(minEnergy,energy);
                }
            }
            dp[i]=minEnergy;
        }
        return dp[n-1];
    }    
public:
    int frogJump(vector<int>& heights, int k) {
        int n=heights.size();
        vector<int>dp(n);
        return solve(heights,k,dp);
    }
};
