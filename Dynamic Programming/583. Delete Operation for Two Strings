//MEMOIZATION
class Solution {
private:
    int longestCommonSubsequence(int index1,int index2,string word1, string word2,vector<vector<int>>&dp){
        int m=word1.size();
        int n=word2.size();

        //base case
        if(index1>=m || index2>=n) return 0;

        if(dp[index1][index2] != -1) return dp[index1][index2];

        //match
        if(word1[index1]==word2[index2]){
            return 1+longestCommonSubsequence(index1+1,index2+1,word1,word2,dp);
        }

        //not match
        else{
            return dp[index1][index2]=max(longestCommonSubsequence(index1+1,index2,word1,word2,dp),
            longestCommonSubsequence(index1,index2+1,word1,word2,dp));
        }
    }    
public:
    int minDistance(string word1, string word2) {
        int m=word1.size();
        int n=word2.size();
        vector<vector<int>>dp(m,vector<int>(n,-1));

        //edge case
        if(word1==word2) return 0;

        int LCS=longestCommonSubsequence(0,0,word1,word2,dp);
        
        return (m+n)-(2*LCS);
    }
};

//TABULATION
class Solution {
private:
    int longestCommonSubsequence(string word1, string word2){
        int m=word1.size();
        int n=word2.size();

        vector<vector<int>>dp(m+1,vector<int>(n+1,0));

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                //match
                if(word1[i-1]==word2[j-1]){
                    dp[i][j]=1+dp[i-1][j-1];
                }

                //not match
                else{
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }    
public:
    int minDistance(string word1, string word2) {
        int m=word1.size();
        int n=word2.size();

        //edge case
        if(word1==word2) return 0;

        int LCS=longestCommonSubsequence(word1,word2);
        
        return (m+n)-(2*LCS);
    }
};

//SPACE OPTIMIZATION
class Solution {
private:
    int longestCommonSubsequence(string word1, string word2){
        int m=word1.size();
        int n=word2.size();

        vector<int>prev(n+1,0);
        vector<int>curr(n+1,0);

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                //match
                if(word1[i-1]==word2[j-1]){
                    curr[j]=1+prev[j-1];
                }

                //not match
                else{
                    curr[j]=max(prev[j],curr[j-1]);
                }
            }
            prev=curr;
        }
        return prev[n];
    }    
public:
    int minDistance(string word1, string word2) {
        int m=word1.size();
        int n=word2.size();

        //edge case
        if(word1==word2) return 0;

        int LCS=longestCommonSubsequence(word1,word2);
        
        return (m+n)-(2*LCS);
    }
};
