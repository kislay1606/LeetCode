//MEMOIZATION
class Solution {
private:
    int solve(int i,int j,string s,string t,vector<vector<int>>&dp){
        int m=s.size();
        int n=t.size();

        //base case
        if(j>=n) return 1; //all chars of t match
        if(i>=m) return 0; //all chars of s are exhausted and t doesnt match

        if(dp[i][j] != -1) return dp[i][j];

        if(s[i]==t[j]){
            return dp[i][j]=solve(i+1,j+1,s,t,dp)+solve(i+1,j,s,t,dp); //matched so look for another match
        }
        else return dp[i][j]=solve(i+1,j,s,t,dp);
    }    
public:
    int numDistinct(string s, string t) {
        int m=s.size();
        int n=t.size();
        vector<vector<int>>dp(m,vector<int>(n,-1));
        return solve(0,0,s,t,dp);
    }
};

//TABULATION
class Solution { 
public:
    int numDistinct(string s, string t) {
        int m=s.size();
        int n=t.size();
        vector<vector<int>>dp(m+1,vector<int>(n+1,0));
        for(int i=0; i<=m; i++) dp[i][0]=1;

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                if(s[i-1]==t[j-1]){
                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j]; //matched so look for another match
                }
                else dp[i][j]=dp[i-1][j];
            }
        }
        return dp[m][n];
    }
};

//SPACE OPTIMIZATION
class Solution { 
public:
    int numDistinct(string s, string t) {
        int m=s.size();
        int n=t.size();

        vector<unsigned long long>prev(n+1,0);
        vector<unsigned long long>curr(n+1,0);
        prev[0]=1;
        
        for(int i=1; i<=m; i++){
            curr[0]=1;
            for(int j=1; j<=n; j++){
                if(s[i-1]==t[j-1]){
                    curr[j]=prev[j-1]+prev[j]; //matched so look for another match
                }
                else curr[j]=prev[j];
            }
            prev=curr;
        }
        return prev[n];
    }
};
