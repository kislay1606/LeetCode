//RECURSION
class Solution {
private:
    int solve(int index,vector<int>&nums){
        //base case
        if(index==0) return nums[index];
        if(index < 0) return 0;

        int rob=nums[index] + solve(index-2,nums);
        int skip=0 + solve(index-1,nums);

        return max(rob,skip);
    }    
public:
    int rob(vector<int>& nums) {
        int n=nums.size();
        return solve(n-1,nums);
    }
};


//MEMOIZATION
class Solution {
private:
    int solve(int index,vector<int>&nums,vector<int>&dp){
        //base case
        if(index==0) return nums[index];
        if(index < 0) return 0;

        if(dp[index] != -1) return dp[index];

        int rob=nums[index] + solve(index-2,nums,dp);
        int skip=0 + solve(index-1,nums,dp);

        return dp[index]=max(rob,skip);
    }    
public:
    int rob(vector<int>& nums) {
        int n=nums.size();
        vector<int>dp(n,-1);
        return solve(n-1,nums,dp);
    }
};


//TABULATION
class Solution {
private:
    int solve(vector<int>&nums,vector<int>&dp){
        int n=nums.size();
        dp[0]=nums[0];

        for(int i=1; i<n; i++){
            int rob=nums[i];
            if(i>1){
                rob=nums[i] + dp[i-2];
            }
            int skip=0 + dp[i-1];

            dp[i]=max(rob,skip);
        }
        return dp[n-1];
    }    
public:
    int rob(vector<int>& nums) {
        int n=nums.size();
        if(n==1) return nums[0];
        vector<int>dp(n);
        return solve(nums,dp);
    }
};


//MEMOIZATION + Space Optimization
class Solution {
public:
    int rob(vector<int>& nums) {
        int n=nums.size();
        if(n==1) return nums[1];

        int prev1=nums[0];
        int prev2=0;

        for(int i=1; i<n; i++){
            int rob=nums[i];
            if(i > 1){
                rob=nums[i]+prev2;
            }
            int skip=0+prev1;

            int curr=max(rob,skip);

            prev2=prev1;
            prev1=curr;
        }
        return prev1;
    }
};
