//MEMOIZATION
class Solution {
private:
    int solve(int i,int buy,vector<int>&prices,vector<vector<int>>&dp){
        int n=prices.size();
        int profit=0;

        //base case
        if(i>=n) return 0;

        if(dp[i][buy] != -1) return dp[i][buy];

        //allowed to buy
        if(buy==1){
            int buy= -prices[i]+solve(i+1,0,prices,dp); //bought so not allowed to buy the next
            int notbuy= 0+solve(i+1,1,prices,dp); //not bought so allowed to buy the next

            profit=max(buy,notbuy);
        }

        //not allowed to buy so sell
        else{
            int sell= prices[i]+solve(i+1,1,prices,dp); //sold so need to buy
            int notsell= 0+solve(i+1,0,prices,dp); //not sold so need to sell the next

            profit=max(sell,notsell);
        }
        return dp[i][buy]=profit;
    }    
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(2,-1));
        return solve(0,1,prices,dp); //index,buy
    }
};

//TABULATION
class Solution {  
public:
    int maxProfit(vector<int>& prices) {
        int profit=0;
        int n=prices.size();
        vector<vector<int>>dp(n+1,vector<int>(2,0));
        dp[0][1]=INT_MIN;
        for(int i=1; i<=n; i++){
            for(int buy=0; buy<2; buy++){
                //allowed to buy
                if(buy==1){
                    int bought= -prices[i-1]+dp[i-1][0]; //bought so not allowed to buy the next
                    int notbought= 0+dp[i-1][1]; //not bought so allowed to buy the next

                    dp[i][buy]=max(bought,notbought);
                }

                //not allowed to buy so sell
                else{
                    int sell= prices[i-1]+dp[i-1][1]; //sold so need to buy
                    int notsell= 0+dp[i-1][0]; //not sold so need to sell the next

                    dp[i][buy]=max(sell,notsell);
                }
            }
        }
        return dp[n][0];
    }
};
