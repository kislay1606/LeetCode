//RECURSION
class Solution {
private:
    int longestPalindromicSubsequence(int index1,int index2,string s,string r){
        int m=s.size();
        int n=r.size();

        //base case
        if(index1>=m || index2>=n) return 0;

        //match
        if(s[index1]==r[index2]){
            return 1+longestPalindromicSubsequence(index1+1,index2+1,s,r);
        }

        //not match
        else return max(longestPalindromicSubsequence(index1+1,index2,s,r),longestPalindromicSubsequence(index1,index2+1,s,r));
    }    
public:
    int minInsertions(string s) {
        int n=s.size();
        string r=s;
        reverse(r.begin(),r.end());
        int LPS=longestPalindromicSubsequence(0,0,s,r);

        return n-LPS;
    }
};

//MEMOIZATION
class Solution {
private:
    int longestPalindromicSubsequence(int index1,int index2,string s,string r,vector<vector<int>>&dp){
        int m=s.size();
        int n=r.size();

        //base case
        if(index1>=m || index2>=n) return 0;

        if(dp[index1][index2] != -1) return dp[index1][index2];

        //match
        if(s[index1]==r[index2]){
            return dp[index1][index2]=1+longestPalindromicSubsequence(index1+1,index2+1,s,r,dp);
        }

        //not match
        else{
            return dp[index1][index2]=max(longestPalindromicSubsequence(index1+1,index2,s,r,dp),
            longestPalindromicSubsequence(index1,index2+1,s,r,dp));
        } 
    }    
public:
    int minInsertions(string s) {
        int n=s.size();
        string r=s;
        reverse(r.begin(),r.end());
        vector<vector<int>>dp(n,vector<int>(n,-1));
        int LPS=longestPalindromicSubsequence(0,0,s,r,dp);

        return n-LPS;
    }
};

//TABULATION
class Solution {
private:
    int longestPalindromicSubsequence(string s,string r){
        int m=s.size();
        int n=r.size();

        vector<vector<int>>dp(m+1,vector<int>(n+1,0));

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                //match
                if(s[i-1]==r[j-1]){
                    dp[i][j]=1+dp[i-1][j-1];
                }

                //not match
                else{
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[m][n]; 
    }    
public:
    int minInsertions(string s) {
        int n=s.size();
        string r=s;
        reverse(r.begin(),r.end());
        int LPS=longestPalindromicSubsequence(s,r);

        return n-LPS;
    }
};


//SPACE OPTIMIZATION
class Solution {
private:
    int longestPalindromicSubsequence(string s,string r){
        int m=s.size();
        int n=r.size();

        vector<int>prev(n+1,0);
        vector<int>curr(n+1,0);

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                //match
                if(s[i-1]==r[j-1]){
                    curr[j]=1+prev[j-1];
                }

                //not match
                else{
                    curr[j]=max(prev[j],curr[j-1]);
                }
            }
            prev=curr;
        }
        return prev[n];
    }    
public:
    int minInsertions(string s) {
        int n=s.size();
        string r=s;
        reverse(r.begin(),r.end());
        int LPS=longestPalindromicSubsequence(s,r);

        return n-LPS;
    }
};
