//RECURSION
class Solution {
private:
    int solve(int index,vector<int>&nums){
        int n=nums.size();
      
        //base case
        if(index==0) return nums[index];
        if(index < 0) return 0;

        int rob=nums[index];
        if(index>1) rob=nums[index]+solve(index-2,nums);
        int skip=0+solve(index-1,nums);

        return max(rob,skip);
    }    
public:
    int rob(vector<int>& nums) {
        int n=nums.size();
        if(n==1) return nums[0];

        vector<int>nums1;
        vector<int>nums2;
        for(int i=0; i<n; i++){
            if(i!=0) nums1.push_back(nums[i]);
            if(i!=n-1) nums2.push_back(nums[i]);
        }
        
        return max(solve(n-2,nums1),solve(n-2,nums2)); //since 1 element is removed so n-2 is last element
    }
};


//MEMOIZATION
class Solution {
private:
    int solve(int index,vector<int>&nums,vector<int>&dp){
        int n=nums.size();
      
        //base case
        if(index==0) return nums[index];
        if(index < 0) return 0;

        if(dp[index] != -1) return dp[index];

        int rob=nums[index];
        if(index>1) rob=nums[index]+solve(index-2,nums,dp);
        int skip=0+solve(index-1,nums,dp);

        return dp[index]=max(rob,skip);
    }    
public:
    int rob(vector<int>& nums) {
        int n=nums.size();
        if(n==1) return nums[0];

        vector<int>nums1;
        vector<int>nums2;
        for(int i=0; i<n; i++){
            if(i!=0) nums1.push_back(nums[i]);
            if(i!=n-1) nums2.push_back(nums[i]);
        }

        vector<int>dp1(n-1,-1);
        vector<int>dp2(n-1,-1);
        
        return max(solve(n-2,nums1,dp1),solve(n-2,nums2,dp2)); //since 1 element is removed so n-2 is last element
    }
};


//TABULATION
class Solution {
private:
    int solve(vector<int>&nums,vector<int>&dp){
        int n=nums.size();

        dp[0]=nums[0];

        for(int i=1; i<n; i++){
            int rob=nums[i];
            if(i>1) rob=nums[i]+dp[i-2];
            int skip=0+dp[i-1];

            dp[i]=max(rob,skip);
        }
        return dp[n-1];
    }    
public:
    int rob(vector<int>& nums) {
        int n=nums.size();
        if(n==1) return nums[0];

        vector<int>nums1;
        vector<int>nums2;
        for(int i=0; i<n; i++){
            if(i!=0) nums1.push_back(nums[i]);
            if(i!=n-1) nums2.push_back(nums[i]);
        }

        vector<int>dp1(n-1);
        vector<int>dp2(n-1);
        
        return max(solve(nums1,dp1),solve(nums2,dp2)); 
    }
};


//TABULATION + Space Optimization
class Solution {
private:
    int solve(vector<int>& nums){
        int n=nums.size();

        int prev1=nums[0];
        int prev2=0;

        for(int i=1; i<n; i++){
            int rob=nums[i]+prev2;
            int skip=0+prev1;

            int curr=max(rob,skip);

            prev2=prev1;
            prev1=curr;
        }
        return prev1;
    } 

public:
    int rob(vector<int>& nums) {
        int n=nums.size();
        if(n==1) return nums[0];

        vector<int>nums1,nums2;
        for(int i=0; i<n; i++){
            if(i!=0) nums1.push_back(nums[i]);
            if(i!=n-1) nums2.push_back(nums[i]);
        }

        return max(solve(nums1),solve(nums2));
    }
};
