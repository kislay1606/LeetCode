class Solution {
private:
    void dijkstra(vector<vector<pair<int,int>>> &adj, int src,vector<int> &dist){
        int n=adj.size();
        dist[src]=0;

        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;
        pq.push({0,src});

        while(!pq.empty()){
            int dis=pq.top().first;
            int node=pq.top().second;
            pq.pop();

            if(dis > dist[node]) continue;
           
            for(auto it:adj[node]){
                int nextnode=it.first;
                int nextdis=it.second;
                int totaldis=nextdis+dis;

                if(totaldis < dist[nextnode]){
                    dist[nextnode]=totaldis;
                    pq.push({totaldis,nextnode});
                }
            }
        }
    }    
public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        vector<vector<pair<int,int>>>adj(n);
        for(int i=0; i<edges.size(); i++){
            int u=edges[i][0];
            int v=edges[i][1];
            int w=edges[i][2];

            adj[u].push_back({v,w});
            adj[v].push_back({u,w});
        }

        int resultcity=-1;
        int minreachable=INT_MAX;

        for(int i=0; i<n; i++){
            vector<int>dist(n,INT_MAX);

            dijkstra(adj,i,dist);
            int count=0;

            for(int j=0; j<n; j++){
                if(j!=i && dist[j] <= distanceThreshold) count++;
            }

            if(count < minreachable || (count == minreachable && i>resultcity)){
                minreachable=count;
                resultcity=i;
            }
        }
        return resultcity;
    }
};
